import {v4 as uuid} from 'uuid'
import { ServerState } from './state'

const state = ServerState()

export const ActionHandler = (io) => {
    
    // Private utility recursive function for handling events generated by the game itself
    const processGameEvent = (tableId, event) => {
        const eventProcessor = state.getEventProcessor(tableId, event)
        let moreEvents = false
        do {
            const {value, done} = eventProcessor.next()
            moreEvents = !done
            state.computePublicStates(tableId) // TODO : how come it works without that line  
            state.getPlayers(tableId).forEach(player => {
                const patch = state.getGameStatePatch4(player, tableId)
                if(patch && patch.length > 0) {
                    io.to(player).emit('action', {type:'gameStatePatched', tableId, patch})
                }
            })
            if(value) processGameEvent(tableId, value)
        } while(moreEvents)
    }
    
    // Set of exposed functions for processing actions requested by the clients (socket)
    return {
        
        connect: (socket) => {
            state.registerSocket(socket.id)
            socket.join('lobby')
        },

        disconnect: (socket) => {
            /*const player = state.getPlayerBySocket(socket.id)
            if(player) {
                state.kick(player)
            }*/
            state.unregisterSocket(socket.id)
            socket.leaveAll()
        },

        login: ({name}, socket) => {
            state.registerPlayer(name, socket.id)
            socket.join(name)
            socket.emit('action', {type:'loggedIn', name:name})
        },

        getAllTables: (action, socket) => {
            socket.emit('action', {type:'refreshTables', tables:state.getTables()})
        },

        createTable: (action, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            const id = state.createTable(player)
            //socket.leave('lobby')
            socket.join(`table/${id}`)
            io.in('lobby').emit('action', {type:'tableCreated', table:state.getTable(id)})
        },

        joinTable: ({id}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            state.joinTable(player, id)
            //socket.leave(`lobby`)
            socket.join(`table/${id}`)
            io.in('lobby').emit('action', {type:'tableUpdated', table:state.getTable(id)})
        },

        readyToPlay: ({tableId}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            state.playerIsReady(player, tableId)
            io.to('lobby').emit('action', {type:'tableUpdated', table:state.getTable(tableId)})
            if(state.getTable(tableId).status === 'READY_TO_START') {
                state.startGame(tableId)
                const gameState = state.getGameState4(player, tableId)
                io.in(`table/${tableId}`).emit('action', {type:'gameStarted', tableId, state:gameState})
                processGameEvent(tableId, state.getFirstGameEvent(tableId))
            }
        },

        getGameState: ({tableId}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            const gameState = state.getGameState4(player, tableId)
            socket.emit('action', {type:'refreshGameState', tableId, state:gameState})
        },

        move: ({tableId, move}, socket) => {
            const activePlayer = state.getPlayerBySocket(socket.id)
            const moveProcessor = state.getMoveProcessor(tableId, activePlayer, move)
            let moreEvents = false
            do {
                const {value, done} = moveProcessor.next()
                moreEvents = !done
                state.computePublicStates(tableId)
                state.getPlayers(tableId).forEach(player => {
                    const patch = state.getGameStatePatch4(player, tableId)
                    if(patch && patch.length > 0) {
                        io.to(player).emit('action', {type:'gameStatePatched', tableId, patch})
                    }
                })
                if(value) processGameEvent(tableId, value)
            } while(moreEvents)
        },

        resign: ({tableId}, socket) => {
            // todo
        }

    }

}