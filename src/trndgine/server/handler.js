import { ServerState } from './state'

const state = ServerState()

export const ActionHandler = (io) => {
    
    // Private utility recursive function for handling events generated by the game itself
    const processGameEvent = (tableId, event, alreadyStarted) => {
        const eventProcessor = alreadyStarted ? event : state.getEventProcessor(tableId, event)
        let moreEvents = false
        do {
            // launch the generator to unfold that game event until its next step
            const {value, done} = eventProcessor.next()
            moreEvents = !done
            // send the state updates to the clients if any
            state.computePublicStates(tableId)
            state.getPlayers(tableId).forEach(player => {
                const patch = state.getGameStatePatch4(player, tableId)
                if(patch && patch.length > 0) {
                    io.to(player).emit('action', {type:'gameStatePatched', tableId, patch})
                }
            })
            // if the next step is another game event generator
            if(typeof value === 'function') {
                // we should process that game event
                processGameEvent(tableId, value)
            }
            // if the generator yields an object created by the special 'expect' action creator
            if(value !== null && typeof value === 'object') {
                const {player, moveHandlers} = value
                // we should register that a move of that type(s) from that player is now allowed
                state.setExpectedMove(tableId, player, moveHandlers, eventProcessor)
                moreEvents = false
            }
            
        } while(moreEvents) // loop over all steps of generators
    }
    
    // Set of exposed functions for processing actions requested by the clients (socket)
    return {
        
        connect: (socket) => {
            state.registerSocket(socket.id)
            socket.join('lobby')
        },

        disconnect: (socket) => {
            /*const player = state.getPlayerBySocket(socket.id)
            if(player) {
                state.kick(player)
            }*/
            state.unregisterSocket(socket.id)
            socket.leaveAll()
        },

        login: ({name}, socket) => {
            state.registerPlayer(name, socket.id)
            socket.join(name)
            socket.emit('action', {type:'loggedIn', name:name})
        },

        getAllTables: (action, socket) => {
            socket.emit('action', {type:'refreshTables', tables:state.getTables()})
        },

        createTable: (action, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            const id = state.createTable(player)
            //socket.leave('lobby')
            socket.join(`table/${id}`)
            io.in('lobby').emit('action', {type:'tableCreated', table:state.getTable(id)})
        },

        joinTable: ({id}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            state.joinTable(player, id)
            //socket.leave(`lobby`)
            socket.join(`table/${id}`)
            io.in('lobby').emit('action', {type:'tableUpdated', table:state.getTable(id)})
        },

        readyToPlay: ({tableId}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            state.playerIsReady(player, tableId)
            io.to('lobby').emit('action', {type:'tableUpdated', table:state.getTable(tableId)})
            if(state.getTable(tableId).status === 'READY_TO_START') {
                state.startGame(tableId)
                const gameState = state.getGameState4(player, tableId)
                io.in(`table/${tableId}`).emit('action', {type:'gameStarted', tableId, state:gameState})
                processGameEvent(tableId, state.getFirstGameEvent(tableId))
            }
        },

        getGameState: ({tableId}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            const gameState = state.getGameState4(player, tableId)
            socket.emit('action', {type:'refreshGameState', tableId, state:gameState})
        },

        move: ({tableId, move}, socket) => {
            // will compare the received move.type with the allowed expected moves
            const player = state.getPlayerBySocket(socket.id)
            const expectedMove = state.getExpectedMove(tableId, move)
            if(!expectedMove) throw 'The game is still processing events and not allowing any player move'
            const {player: expectedPlayer, moveHandlers, eventProcessor} = expectedMove
            if(expectedPlayer != player) throw 'It is not your turn'

            // if a move of that type was expected at this moment for this player, go ahead

            const moveProcessor = moveHandlers.filter(f => f.name === move.type)?.[0]
            if(!moveProcessor) throw 'You cannot perform this action'

            let moreEvents = false
            const moveGenerator = state.getEventProcessor(tableId, moveProcessor(player, move))
            do {
                const {value, done} = moveGenerator.next()
                state.setExpectedMove(tableId, null, null, null)
                moreEvents = !done
                state.computePublicStates(tableId)
                state.getPlayers(tableId).forEach(player => {
                const patch = state.getGameStatePatch4(player, tableId)
                    if(patch && patch.length > 0) {
                        io.to(player).emit('action', {type:'gameStatePatched', tableId, patch})
                    }
                })
                if(typeof value === 'function') {
                    // If the generator yields another generator, we should process that game event
                    processGameEvent(tableId, value)
                }
                else if(value !== null && typeof value === 'object') {
                    // If the generator yields an object created by the special 'expect' action creator
                    const {player, moveHandlers} = value
                    state.setExpectedMove(tableId, player, moveHandlers, eventProcessor)
                    moreEvents = false
                }
            } while(moreEvents)

            // TODO : should now relaunch the expectedMove.eventProcessor
            processGameEvent(tableId, eventProcessor, true)

        },

        resign: ({tableId}, socket) => {
            // TODO
        }

    }

}