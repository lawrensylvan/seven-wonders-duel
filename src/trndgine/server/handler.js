import { ServerState } from './state'

const state = ServerState()

export const ActionHandler = (io) => {
    
    // Private utility recursive function for handling events generated by the game itself
    const processGameEvent = (tableId, flow) => {
        let moreEvents = false
        do {
            // launch the generator to unfold that game event until its next step
            const {value, done} = flow.next()
            moreEvents = !done
            // send the state updates to the clients if any
            state.computePublicStates(tableId)
            state.getPlayers(tableId).forEach(player => {
                const patch = state.getGameStatePatch4(player, tableId)
                if(patch && patch.length > 0) {
                    io.to(player).emit('action', {type:'gameStatePatched', tableId, patch})
                }
            })
            // if the generator yields an object created by the special 'expect' action creator
            if(value) {
                const {player, moveHandlers} = value
                // we should register that a move of that type(s) from that player is now allowed
                state.registerExpectedMove(tableId, player, moveHandlers, flow)
                moreEvents = false
            }
            
        } while(moreEvents) // loop over all steps of generators
    }
    
    // Set of exposed functions for processing actions requested by the clients (socket)
    return {
        
        connect: (socket) => {
            state.registerSocket(socket.id)
            socket.join('lobby')
        },

        disconnect: (socket) => {
            /*const player = state.getPlayerBySocket(socket.id)
            if(player) {
                state.kick(player)
            }*/
            state.unregisterSocket(socket.id)
            socket.leaveAll()
        },

        login: ({name}, socket) => {
            state.registerPlayer(name, socket.id)
            socket.join(name)
            socket.emit('action', {type:'loggedIn', name:name})
        },

        getAllTables: (action, socket) => {
            socket.emit('action', {type:'refreshTables', tables:state.getTables()})
        },

        createTable: (action, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            const id = state.createTable(player)
            //socket.leave('lobby')
            socket.join(`table/${id}`)
            io.in('lobby').emit('action', {type:'tableCreated', table:state.getTable(id)})
        },

        joinTable: ({id}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            state.joinTable(player, id)
            //socket.leave(`lobby`)
            socket.join(`table/${id}`)
            io.in('lobby').emit('action', {type:'tableUpdated', table:state.getTable(id)})
        },

        readyToPlay: ({tableId}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            state.playerIsReady(player, tableId)
            io.to('lobby').emit('action', {type:'tableUpdated', table:state.getTable(tableId)})
            if(state.getTable(tableId).status === 'READY_TO_START') {
                state.startGame(tableId)
                const gameState = state.getGameState4(player, tableId)
                io.in(`table/${tableId}`).emit('action', {type:'gameStarted', tableId, state:gameState})
                processGameEvent(tableId, state.getFirstGameEvent(tableId))
            }
        },

        getGameState: ({tableId}, socket) => {
            const player = state.getPlayerBySocket(socket.id)
            const gameState = state.getGameState4(player, tableId)
            socket.emit('action', {type:'refreshGameState', tableId, state:gameState})
        },

        move: ({tableId, move}, socket) => {
            // will compare the received move.type with the allowed expected moves
            const player = state.getPlayerBySocket(socket.id)
            const moveHandler = state.getExpectedMoveHandler(tableId, player, move)
            if(!moveHandler) throw 'The game is not expecting that move from you'
            // if a move of that type was expected at this moment for this player, go ahead
            processGameEvent(tableId, state.getGameFlow(tableId)[moveHandler.name](player, move))
            // if no exception, move went fine and we can resume game flow
            const parentFlow = state.popGameFlow(tableId)
            processGameEvent(tableId, parentFlow)
        },

        resign: ({tableId}, socket) => {
            // TODO
        }

    }

}